function thetad = inverse_kinematics(u)% performs inverse kinematics computations with various methods% Stefan Schaal, March 2009% split the input u into meaningful quantitiesn = (length(u)-3)/2;theta = u(1:n);xd    = u(n+1:n+3);links = u(n+4:end);%test case% n=8;% theta = [0 .125 0 .125 0 .125 0 .125]'% links = [0.1 0.0 0.1 0.0 0.1 0.0 0.1 0.0]';% xd = [1 1 0]';% NOTE: insert your Jacobian calculation here% Declare p-vectorsp=zeros(3,n+1);for i=3:2:n+1 %i index starts at p0 (e.g. p0 corresponds to i = 1)    ang = 0; %intialize angle for use in p-vector calculation    for j = 1:2:i-1        ang = ang + theta(j);    end %for    %calculate p-vector    p(1,i) = p(1,i-2) + (links(i-2) + theta(i-1))*cos(ang);    p(2,i) = p(2,i-2) + (links(i-2) + theta(i-1))*sin(ang);    p(3,i) = 0;%     ang%     pend %for%z vectors (local rotation axes per DH covention)z = [0 cos(theta(1)) 0 cos(theta(1) + theta(3)) 0 cos(theta(1) + theta(3) + theta(5)) 0 cos(theta(1) + theta(3) + theta(5) + theta(7));    0 sin(theta(1)) 0 sin(theta(1) + theta(3)) 0 sin(theta(1) + theta(3) + theta(5)) 0 sin(theta(1) + theta(3) + theta(5) + theta(7));    1 0 1 0 1 0 1 0];%zero vectorzeroV = zeros(1,3)';%Top three rows of Jacobian -> JpJ_top = [...    [cross( z(:,1),(p(:,9) - p(:,1)) )],...    [z(:,2)],...    [cross( z(:,3),(p(:,9) - p(:,3)) )],...    [z(:,4)],...    [cross( z(:,5),(p(:,9) - p(:,5)) )],...    [z(:,6)],...    [cross( z(:,7),(p(:,9) - p(:,7)) )],...    [z(:,8)]...    ];%Bottom three rows of Jacobian -> JoJ_bot = [...    z(:,1),...    zeroV,...    z(:,3),...    zeroV,...    z(:,5),...    zeroV,...    z(:,7),...    zeroV    ];%JacobianJ = [J_top;J_bot];%Truncated Jacobian that has only non-static components (e.g. matrix rows) of the planar arm dynamicsJ_trunc = [J(1,:);J(2,:);J(end,:)];% convert cartesian velocities into joint velocities% NOTE: insert the required inverse kinematics methods at this%       location%global invMethod %call the inverse kinematics toggle from HW2_Run.mswitch(invMethod) %call the inverse kinematics toggle from HW2_Run.m    case {1} %Jacobian Transpose (prob. 1d)        alp = 0.25; %multiplier        thetad = alp*transpose(J_trunc)*xd;    case {2} %Psuedo-Inverse (prob. 1e)        alp = 0.25; %multiplier        weights = ones(1,n); %weighting matrix is I for weight-independent psuedo-matrix        w = diag(weights,0);        J_dagger = inv(w) * transpose(J_trunc) * inv(J_trunc*inv(w)*transpose(J_trunc));        thetad = alp * J_dagger * xd;    case {3} %Psuedo-Inverse with null space optimization (prob. 1f)        alp = 0.25; %multiplier        weights = ones(1,n); %weighting matrix is I for weight-independent psuedo-matrix        w = diag(weights,0);        theta_null = zeros(size(theta));        J_dagger = inv(w) * transpose(J_trunc) * inv(J_trunc*inv(w)*transpose(J_trunc));        thetad = alp*J_dagger*xd + (eye(n) - J_dagger*J_trunc)*(theta_null - theta);    case {4} %Weighted Psuedo-Inverse (prob. 1g)        alp = 0.50; %multiplier        weights = [1000, 0.1, 100, 0.1, 10, 0.1, 1, 0.1]; %weight vector of W inverse        %weights stand to minimize the use of the prismatic joints and maximize use of revolute joints        wInv = diag(weights,0);        J_dagger = wInv * transpose(J_trunc) * inv(J_trunc*wInv*transpose(J_trunc));        thetad = alp*J_dagger*xd;    case {5} %Weighted Psuedo-Inverse and non-weighted psuedo-invere for null optimatzion (prob. 1h)        alp = 0.25; %multiplier        weights = [1000, 0.1, 100, 0.1, 10, 0.1, 1, 0.1]; %weight vector of W inverse        %weights stand to minimize the use of the prismatic joints and maximize use of revolute joints        wInv = diag(weights,0);        theta_null = zeros(size(theta));        J_dagger1 = wInv * transpose(J_trunc) * inv(J_trunc*wInv*transpose(J_trunc)); %weighted psuedo inverse        J_dagger2 = transpose(J_trunc) * inv(J_trunc*transpose(J_trunc)); %non-weighted psuedo inverse        thetad = alp*J_dagger1*xd + (eye(n) - J_dagger2*J_trunc)*(theta_null - theta);    case {6} %Weighted Psuedo-Inverse with weights to inhibit prismatic joint movement (prob. 1h)        alp = 0.25; %multiplier        weights = [1000, 0.001, 100, 0.001, 100, 0.001, 100, 0.001]; %weight vector of W inverse        %weights stand to inhibit the use of the prismatic joints and only use revolute joints        wInv = diag(weights,0);        J_dagger = wInv * transpose(J_trunc) * inv(J_trunc*wInv*transpose(J_trunc));        thetad = alp*J_dagger*xd;end            